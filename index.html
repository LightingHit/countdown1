<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Countdown</title>
<link href="https://fonts.googleapis.com/css2?family=Syne+Mono&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0a0a0f;
    --card1: #111120;
    --accent1: #ff4d6d;
    --accent2: #7b61ff;
    --text: #f0f0f8;
    --muted: #5a5a80;
    --glow1: rgba(255,77,109,0.3);
    --glow2: rgba(123,97,255,0.3);
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Syne', sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 24px 16px 40px;
    gap: 28px;
  }

  header {
    text-align: center;
    margin-top: 8px;
  }
  header h1 {
    font-size: 13px;
    font-weight: 400;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: var(--muted);
  }

  .card {
    width: 100%;
    max-width: 380px;
    background: var(--card1);
    border-radius: 24px;
    padding: 28px 22px 26px;
    position: relative;
    overflow: hidden;
    border: 1px solid rgba(255,255,255,0.05);
  }
  .card::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 24px;
    pointer-events: none;
  }
  .card-1::before { box-shadow: inset 0 0 80px var(--glow1); }
  .card-2::before { box-shadow: inset 0 0 80px var(--glow2); }

  .card-label {
    font-size: 10px;
    letter-spacing: 3px;
    text-transform: uppercase;
    margin-bottom: 6px;
  }
  .card-1 .card-label { color: var(--accent1); }
  .card-2 .card-label { color: var(--accent2); }

  .card-date {
    font-size: 26px;
    font-weight: 800;
    letter-spacing: -0.5px;
    margin-bottom: 28px;
    line-height: 1;
  }

  .circle-row {
    display: flex;
    justify-content: center;
    margin-bottom: 24px;
  }

  .ring-wrap {
    position: relative;
    width: 130px;
    height: 130px;
  }
  .ring-wrap svg {
    transform: rotate(-90deg);
    width: 130px;
    height: 130px;
  }
  .ring-bg {
    fill: none;
    stroke: rgba(255,255,255,0.06);
    stroke-width: 8;
  }
  .ring-progress {
    fill: none;
    stroke-width: 8;
    stroke-linecap: round;
    transition: stroke-dashoffset 0.9s cubic-bezier(0.4,0,0.2,1);
  }
  .card-1 .ring-progress { stroke: var(--accent1); filter: drop-shadow(0 0 6px var(--accent1)); }
  .card-2 .ring-progress { stroke: var(--accent2); filter: drop-shadow(0 0 6px var(--accent2)); }

  .ring-center {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 2px;
  }
  .ring-pct {
    font-family: 'Syne Mono', monospace;
    font-size: 18px;
    font-weight: 700;
    line-height: 1;
  }
  .ring-sublabel {
    font-size: 9px;
    letter-spacing: 2px;
    color: var(--muted);
    text-transform: uppercase;
  }

  .units-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
  }
  .unit {
    background: rgba(255,255,255,0.04);
    border-radius: 12px;
    padding: 12px 4px 10px;
    text-align: center;
    border: 1px solid rgba(255,255,255,0.05);
  }
  .unit-val {
    font-family: 'Syne Mono', monospace;
    font-size: 22px;
    font-weight: 700;
    line-height: 1;
    display: block;
  }
  .card-1 .unit-val { color: var(--accent1); }
  .card-2 .unit-val { color: var(--accent2); }
  .unit-name {
    font-size: 9px;
    letter-spacing: 2px;
    color: var(--muted);
    text-transform: uppercase;
    margin-top: 5px;
    display: block;
  }

  /* stylish bg */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    z-index: 0;
    background:
      radial-gradient(ellipse 80% 60% at 20% 10%, rgba(255,77,109,0.22) 0%, transparent 60%),
      radial-gradient(ellipse 70% 55% at 85% 85%, rgba(123,97,255,0.24) 0%, transparent 60%),
      radial-gradient(ellipse 55% 45% at 55% 45%, rgba(80,40,180,0.12) 0%, transparent 55%),
      radial-gradient(ellipse 60% 60% at 5% 75%, rgba(255,50,80,0.1) 0%, transparent 55%);
    animation: bgShift 14s ease-in-out infinite alternate;
  }
  body::after {
    content: '';
    position: fixed;
    inset: 0;
    z-index: 0;
    background-image:
      repeating-linear-gradient(0deg, transparent, transparent 39px, rgba(255,255,255,0.018) 40px),
      repeating-linear-gradient(90deg, transparent, transparent 39px, rgba(255,255,255,0.018) 40px);
    pointer-events: none;
  }
  @keyframes bgShift {
    0%   { transform: scale(1) translate(0, 0); }
    25%  { transform: scale(1.05) translate(1.5%, 2%); }
    50%  { transform: scale(0.97) translate(-1%, -1.5%); }
    75%  { transform: scale(1.03) translate(-2%, 1%); }
    100% { transform: scale(1.01) translate(1%, -2%); }
  }

  canvas#particles {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
  }
  body > * { position: relative; z-index: 1; }

  .done-msg {
    font-size: 18px;
    font-weight: 700;
    text-align: center;
    padding: 16px 0;
  }
</style>
</head>
<body>

<canvas id="particles"></canvas>

<header>
  <h1>Time Remaining</h1>
</header>

<!-- Card 1: March 16 -->
<div class="card card-1">
  <div class="card-label">Countdown #1</div>
  <div class="card-date">March 16, 2025</div>
  <div class="circle-row">
    <div class="ring-wrap" id="ring1-wrap">
      <svg viewBox="0 0 130 130">
        <circle class="ring-bg" cx="65" cy="65" r="56"/>
        <circle class="ring-progress" id="ring1" cx="65" cy="65" r="56"
          stroke-dasharray="351.86" stroke-dashoffset="351.86"/>
      </svg>
      <div class="ring-center">
        <span class="ring-pct" id="pct1">0%</span>
        <span class="ring-sublabel">elapsed</span>
      </div>
    </div>
  </div>
  <div class="units-grid" id="units1">
    <div class="unit"><span class="unit-val" id="d1">00</span><span class="unit-name">Days</span></div>
    <div class="unit"><span class="unit-val" id="h1">00</span><span class="unit-name">Hours</span></div>
    <div class="unit"><span class="unit-val" id="m1">00</span><span class="unit-name">Mins</span></div>
    <div class="unit"><span class="unit-val" id="s1">00</span><span class="unit-name">Secs</span></div>
  </div>
</div>

<!-- Card 2: April 5 -->
<div class="card card-2">
  <div class="card-label">Countdown #2</div>
  <div class="card-date">April 5, 2025</div>
  <div class="circle-row">
    <div class="ring-wrap" id="ring2-wrap">
      <svg viewBox="0 0 130 130">
        <circle class="ring-bg" cx="65" cy="65" r="56"/>
        <circle class="ring-progress" id="ring2" cx="65" cy="65" r="56"
          stroke-dasharray="351.86" stroke-dashoffset="351.86"/>
      </svg>
      <div class="ring-center">
        <span class="ring-pct" id="pct2">0%</span>
        <span class="ring-sublabel">elapsed</span>
      </div>
    </div>
  </div>
  <div class="units-grid" id="units2">
    <div class="unit"><span class="unit-val" id="d2">00</span><span class="unit-name">Days</span></div>
    <div class="unit"><span class="unit-val" id="h2">00</span><span class="unit-name">Hours</span></div>
    <div class="unit"><span class="unit-val" id="m2">00</span><span class="unit-name">Mins</span></div>
    <div class="unit"><span class="unit-val" id="s2">00</span><span class="unit-name">Secs</span></div>
  </div>
</div>

<script>
  // Detect the year: if the date has passed in 2025, use 2026
  function getTarget(month, day) {
    const now = new Date();
    let year = now.getFullYear();
    const candidate = new Date(year, month - 1, day, 0, 0, 0, 0);
    if (candidate <= now) year++;
    return new Date(year, month - 1, day, 0, 0, 0, 0);
  }

  // Percentage starts counting from July 7, 2025
  const sharedStart = new Date(2025, 6, 7, 0, 0, 0, 0); // month is 0-indexed

  const target1 = getTarget(3, 16);
  const target2 = getTarget(4, 5);
  const start1 = sharedStart;
  const start2 = sharedStart;

  // Update date labels with correct year
  document.querySelector('.card-1 .card-date').textContent =
    `March 16, ${target1.getFullYear()}`;
  document.querySelector('.card-2 .card-date').textContent =
    `April 5, ${target2.getFullYear()}`;

  const CIRCUM = 351.86;

  function pad(n) { return String(Math.floor(n)).padStart(2, '0'); }

  function update(target, start, ids) {
    const now = new Date();
    const total = target - start;
    const elapsed = now - start;
    const remaining = target - now;

    if (remaining <= 0) {
      document.getElementById(ids.d).textContent = '00';
      document.getElementById(ids.h).textContent = '00';
      document.getElementById(ids.m).textContent = '00';
      document.getElementById(ids.s).textContent = '00';
      const pctVal = 100;
      document.getElementById(ids.pct).textContent = '100%';
      document.getElementById(ids.ring).style.strokeDashoffset = 0;
      return;
    }

    const secs = remaining / 1000;
    const days = Math.floor(secs / 86400);
    const hours = Math.floor((secs % 86400) / 3600);
    const mins = Math.floor((secs % 3600) / 60);
    const s = Math.floor(secs % 60);

    document.getElementById(ids.d).textContent = pad(days);
    document.getElementById(ids.h).textContent = pad(hours);
    document.getElementById(ids.m).textContent = pad(mins);
    document.getElementById(ids.s).textContent = pad(s);

    const pct = Math.min(100, Math.max(0, (elapsed / total) * 100));
    document.getElementById(ids.pct).textContent = pct.toFixed(3) + '%';
    const offset = CIRCUM - (pct / 100) * CIRCUM;
    document.getElementById(ids.ring).style.strokeDashoffset = offset;
  }

  const ids1 = { d:'d1', h:'h1', m:'m1', s:'s1', pct:'pct1', ring:'ring1' };
  const ids2 = { d:'d2', h:'h2', m:'m2', s:'s2', pct:'pct2', ring:'ring2' };

  function tick() {
    update(target1, start1, ids1);
    update(target2, start2, ids2);
  }
  tick();
  setInterval(tick, 1000);

  // Stylish particle system: glowing orbs + shooting streaks
  const canvas = document.getElementById('particles');
  const ctx = canvas.getContext('2d');
  let W, H;
  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  // Floating orbs
  const orbs = Array.from({length: 18}, () => ({
    x: Math.random() * 1000, y: Math.random() * 2000,
    r: Math.random() * 3 + 1,
    vx: (Math.random() - 0.5) * 0.18,
    vy: (Math.random() - 0.5) * 0.18,
    c: Math.random() > 0.5 ? 'rgba(255,77,109,' : 'rgba(123,97,255,',
    alpha: Math.random() * 0.6 + 0.3,
    pulse: Math.random() * Math.PI * 2
  }));

  // Shooting streaks
  const streaks = Array.from({length: 6}, () => newStreak());
  function newStreak() {
    return {
      x: Math.random() * 1500 - 200,
      y: Math.random() * -200,
      len: Math.random() * 80 + 40,
      speed: Math.random() * 2.5 + 1.5,
      angle: Math.PI / 4 + (Math.random() - 0.5) * 0.3,
      alpha: Math.random() * 0.4 + 0.1,
      c: Math.random() > 0.5 ? '255,77,109' : '123,97,255',
      w: Math.random() * 1.2 + 0.4
    };
  }

  let t = 0;
  function animParticles() {
    ctx.clearRect(0, 0, W, H);
    t += 0.012;

    // Draw orbs
    orbs.forEach(d => {
      d.x += d.vx; d.y += d.vy;
      d.pulse += 0.02;
      if (d.x < -20) d.x = W + 20;
      if (d.x > W + 20) d.x = -20;
      if (d.y < -20) d.y = H + 20;
      if (d.y > H + 20) d.y = -20;
      const pulse = 0.7 + 0.3 * Math.sin(d.pulse);
      const grd = ctx.createRadialGradient(d.x, d.y, 0, d.x, d.y, d.r * 5);
      grd.addColorStop(0, d.c + (d.alpha * pulse) + ')');
      grd.addColorStop(1, d.c + '0)');
      ctx.beginPath();
      ctx.arc(d.x, d.y, d.r * 5, 0, Math.PI * 2);
      ctx.fillStyle = grd;
      ctx.fill();
      // core dot
      ctx.beginPath();
      ctx.arc(d.x, d.y, d.r, 0, Math.PI * 2);
      ctx.fillStyle = d.c + (d.alpha * pulse) + ')';
      ctx.fill();
    });

    // Draw streaks
    streaks.forEach((s, i) => {
      s.x += Math.cos(s.angle) * s.speed;
      s.y += Math.sin(s.angle) * s.speed;
      if (s.y > H + 50 || s.x > W + 50) {
        streaks[i] = newStreak();
        return;
      }
      const x2 = s.x - Math.cos(s.angle) * s.len;
      const y2 = s.y - Math.sin(s.angle) * s.len;
      const grd = ctx.createLinearGradient(x2, y2, s.x, s.y);
      grd.addColorStop(0, `rgba(${s.c},0)`);
      grd.addColorStop(1, `rgba(${s.c},${s.alpha})`);
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(s.x, s.y);
      ctx.strokeStyle = grd;
      ctx.lineWidth = s.w;
      ctx.stroke();
    });

    requestAnimationFrame(animParticles);
  }
  animParticles();
</script>
</body>
</html>
